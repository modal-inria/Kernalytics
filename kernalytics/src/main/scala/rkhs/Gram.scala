package rkhs

import breeze.linalg._
import various.TypeDef._

object Gram {
  /**
   * Observations are presented in a matrix, where each row is an observation, and each
   * column is a variable. The kernel is passed as an argument.
   */
  def generate[Data](
    observations: DenseVector[Data],
    kernel: (Data, Data) => Real): DenseMatrix[Real] = {
    val nObs = observations.length

    return DenseMatrix.tabulate[Real](nObs, nObs)((i, j) => kernel(observations(i), observations(j)))
  }

  /**
   * Scalar product between two arbitrary RKHS vectors located in the sub-space generated by the observations.
   * TODO: should not use the Gram matrix, but a KerEval
   *
   * @param x coefficients for the first vector, in the same base of observations used in the Gram matrix
   * @param y coefficients for the second vector
   */
  def scalarProduct(
    gram: DenseMatrix[Real],
    x: DenseVector[Real],
    y: DenseVector[Real]): Real = {
    val nElem = x.length
    val intermediate = DenseMatrix.tabulate[Real](nElem, nElem)((i, j) => x(i) * y(j) * gram(i, j))
    return sum(intermediate)
  }

  def generateTest {
    val obs = DenseVector[DenseVector[Real]](
      DenseVector[Real](1.0, 2.0),
      DenseVector[Real](3.0, 4.0),
      DenseVector[Real](5.0, 6.0))

    //    val gram = generate(obs, Kernel.Legacy.Rn.linear)

    val ker = Kernel.InnerProduct.linear(
      _: DenseVector[Real],
      _: DenseVector[Real],
      Algebra.DenseVectorReal.InnerProductSpace)

    val gram = generate(obs, ker)

    println(gram)
  }
}
